<h1>Expressions</h1>

I don't want to scare you.  The text we use in Warpseq to reference notes can be very basic.  However, it can also
be more feature-rich, allowing for expressions that involve randomness and other musical features, to prevent our (usually electronic)
music to fall into ruts.

The goal of Warpseq is to be easily able to express composer intent, and that includes variation, such as subtle note changes
on certain steps as commonly found in acid or minimal techno.  To achieve this, we need tools for expressing this.

Expressions are used not only in describing what notes play, they are also used in arpeggiators -- essentially the tools that take
basic patterns and make them shred mercilessly -- or at least, sound a lot more musical.

Most importantly, all of these systems work in the concept of the current scale, so they always stay musical, and also allow for
key changes and variations without manual transcription.

Ready to go down the rabbit hole? Here we go.

If this is still confusing, we recommend looking at some of the example songs that come with Warp, and things should make a lot
more sense in context.

<h2>The Basics</h2>

Each pattern in Warpseq is not just a set of notes in a list, but a flexible expression.

<h3>Arabic Numbers Are Relative Notes</h3>

Think about playing a musical scale.  If the scale is "C-major", then that scale is "C D E F G A B C".

In Warp, this can be expressed by a simple numeral sequence, "1 2 3 4 5 6 7 8".

This means that we can define a pattern (see {{ doc('concepts') }}) and then the pattern can be then applied
to any scale we want. By contrast, most sequencer programs and DAWs do not natively understand scales, but instead
"force" notes to the nearest scale note.

<h3>Absolute Notes Are Also Ok</h3>

If you don't need to select notes within a scale, it is also possible to use absolutes like "C4, "Eb5", "F5#", and so on.
The octave number is required.

<h3>Roman Numeral Chords</h3>

For utmost simplicity, chords can be expressed as Roman numerals. For instance "I IV V" represents the first, fourth, and fifth
major chord of the current scale.

Lowercase roman numerals represent minor chords: "i iv v".

More advanced types can be represented using their base notes "1;ch=sus4" or "4;ch=power", etc.  This is a bit of a spoiler
as this refers to "Mod Expressions", immediately below.

The built-in chord types are:

<ul>
<li>minor</li>
<li>major</li>
<li>dim</li>
<li>aug</li>
<li>sus4</li>
<li>sus2</li>
<li>fourth</li>
<li>power</li>
<li>fifth</li>
<li>M6</li>
<li>m6</li>
<li>dom7</li>
<li>M7</li>
<li>m7</li>
<li>aug7</li>
<li>dim7</li>
<li>mM7</li>
</ul>

<h2>Gaps</h2>

The symbol "_" or "x" (or an empty line in the UI) represents a slot in a pattern where nothing should play.

<pre>
1
2
3
_
1
2
3
</pre>


<h2>Ties</h2>

A hyphen in a step extends the note out for an additional note duration, Here we have some longer chords held for
four notes each and then part of a scale:

<pre>
IV
-
-
-
iii
-
-
-
1
2
3
4
5
</pre>

Since all notes in a pattern are by default the same length, longer notes are created by using ties.  The system does
not allow for playing broken chords (arpeggiators exist however!), but if you desire the ability to play broken
chords, you can have multiple tracks target the same instrument, and that is an easy way to accomplish this.

<h2>Ties</h2>

<h2>Mod Expressions</h2>

As an advanced feature, any expression may be followed by a semicolon and one or more modifiers, seperated by semicolons.

<h3>Octave Shifts</h3>

A basic example shows some octave offsets.  Assuming the scale was C major and the base octave was 4...

{{ begin_code() }}
1;O+1
1;O-2
2;O=4
{{ end_code() }}

... the above set of patterns would produce a C5, a C2, and D4.

<h3>Velocity Controls</h3>

velocity can be adjusted in one of many ways.

{{ begin_code() }}
1;v=100
2;v+10
3;v-10
{{ end_code() }}

Velocity takes a value between 0 and 100, and does not always map to  volume - it depends on your instrument.
The latter two examples might be interesting in arpeggiators. See the "Randomness" section below for more tricks involving
MIDI velocity.

<h3>MIDI CC Controls</h3>

MIDI CCs can be used to add interesting variations.

{{ begin_code() }}
1;cc1=20
4;
10;cc1=80
{{ end_code() }}

In the above example, the MIDI CC value for channel 1 is "20" for the first 2 notes, and 80 for the last note.
MIDI CCs are sticky. See the "Randomness" section below for more tricks involving MIDI CCs.

<h3>Degree Shifts</h3>

Making a note go up or down a scale interval works as follows:

{{ begin_code() }}
1;+5
1;-b3
{{ end_code() }}

<h3>Flats and Sharps</h3>

Accidentals outside the scale are easy to access:

{{ begin_code() }}
1
2
3;b
4;
5;#
6;
7
{{ end_code() }}

Note that sometimes the accidentals will still be inside the scale.  It depends on the scale.

<h3>Scale Shifts</h3>

scale shifts can jump a note up or down in the current scale:

{{ begin_code() }}
1;S+2
4;S-2
{{ end_code() }}

This may seem pointless, because we could have just said "3" or "2" here, but these can be used in powerful ways inside
of arpeggiators.

<h3>Probability Events</h3>

A probability event can be assigned so that the next event has only a partial chance of firing.

{{ begin_code() }}
1;p=0.5;O+2
{{ end_code() }}

In the above example, the note will jump an octave only half of the times the pattern plays.

<h3>Silence Events</h3>

Silences are most useful with probabilities.

{{ begin_code() }}
1;p=0.5;x
{{ end_code() }}

In the above example, the event will not play half of the time

<h3>Chordification</h3>

While chords can be explicitly entered, chords can also be created from mod expressions in patterns or in arpeggiators.
See the "Randomness" section below for more tricks involving chords.

{{ begin_code() }}
1;ch=power
4;ch=major
3;ch=sus4
{{ begin_code() }}

<h2>Randomness</h2>


There are two forms of randomness supplied.

<h3>Random Range</h3>

The first form picks a value between a range.  Here we randomly jump
the third note in a pattern by between 0 and 4 octaves each time it plays:

<pre>
1
2
3;O+0:4
4
</pre>

<h3>Random Choice</h3>

The second form involves choosing from a list, which allows some control over probability distribution if an entry
appears in a list more than once.

<pre>
3;O+0,2,3
</pre>

In the above example, the note jumps 0, 2 or 3 octaves, but the chance of an octave jump is 50%, because two of the values
are zero.

<h3>Randomness for Humanization</h3>

Humanizing otherwise repetitive patterns is a popular feature in many sequencers, and here's an example
of humanizing velocity in Warp while playing a two octave scale, with every four notes being full volume.

<pre>
1;v=127
2;v=60:80
3;v=60:80
4;v=60:80
5;v=127
6;v=60:80
7;v=60:80
8;v=60:80
9;v=127
10;v=60:80
11;v=60:80
12;v=60:80
13;v=127
14;v=60:80
15;v=60:80
16;v=60:80
</pre>

Because CC's are sticky between notes, assigning random values to CC values can work like a tempo-synced sample
and hold.  The example below changes twice in each pattern iteration.

<pre>
1;cc0=0:127
2
3
4
5
6;cc0=0:127
7
8
9
10
</pre>

<h3>Note Grabs</h3>

Note grabs allow one track to replace the value of what note should play based on using the value of another track's last
played note.

This allows for powerful harmonization.  Imagine, if you will, a muted track 1 containing melody information as part of a scale.

<pre>
1
2
3
4
1;O+1
2
4
1;O+2
1
3
</pre>

Another track can play harmonized chords - even at a different tempo, that will always line up.  This is as if one player in a band
was listening to another player:

<pre>
1;T=melodyTrack;ch=major
-
-
-
1;T=melodyTrack;ch=minor
-
-
-
-
</pre>

That's a short pattern.  Now we can add a baseline, which takes the melody track and drops down a few octaves.

<pre>
1;T=melodyTrack
</pre>

The bass pattern can be zero length, because we want to apply an arp pattern to it, that might look like this:

<pre>
1;T=melodyTrack;O-1
1;T=melodyTrack;O-1;S+1
1;T=melodyTrack;O-1;S+2
1;T=melodyTrack;O-1;S+3
</pre>

The arp plays the first note the melody track is playing, then three successive notes going up 1, 2, and then 3 scale
notes, all in key, but also one octave down.

While the data entry of this may SEEM a little tedious, these same patterns can be played throughout large parts of the
song (if desired), and do not need to be rewritten when varying the melody track.

As such, we can make an entire song out of considerably LESS clips than in some other systems, by reusing patterns like this.

<h3>Variable Engine</h3>

Warp contains a variable engine where variables can be shared between tracks and scenes.  The variables
are set and accessed as follows, and CAN be used in conjunction with the randomness features above.

<pre>
1;$x=5;$y=10
2;$z=20
3;
4;cc0=$x
5;$y=0:50
6;cc1=$y
7;
8;cc0=0:$y
9
10;cc0=$x
11;
</pre>

The above example is a little crazy, but the basics are that variables can be substituted anywhere a number can
be in a modifier expression.  Variables can also hold strings, like so:

<pre>
_;$x=power,major,minor
4;ch=$x
8;ch=$x
</pre>

In the above example, the first in the pattern is silent, and then we play two chords of the same type.

The variable engine can be mostly ignored if you don't want to use it, but could be interesting in more
complex works.

<h3>Mod Expressions As Applied To Arps</h3>

Arpeggiators also use mod expressions, though the patterns for arps do not start with notes.
For instance, an arp pattern sequence might look like this:

<pre>
O+2
O+1
0
O+1
O+2
</pre>

The above sequence would play the first note in the arp 2 octaves up, the 1, then as written, then 1 up, and then 2 up.

Alternatively, the arp can ALSO muck with any parameter it wants, including creation of chords.  Here is a particularly
non-musical example:

<pre>
0
0;cc10=90;v=80
x
O+1
0;cc10=0:120
</pre>

In this example, the first note plays as is, the second does with modified velocity and MIDI CC 10, the third
note is silenced, the fourth note is an octave up, and the fifth note plays as is with random MIDI CC information that
will persist as the arp cycles back on the first slot and finally be overwritten on the second.


<h3>The Future of Mod Expressions</h3>

Warp is always open to add new ideas for mod expressions. If you have an idea, see {{ doc('club') }} for how to get
share it.

If this looks complicated, don't get frustrated. When learning Warp, it is fine to start with simple expressions,
like the scale, or mixing scales and chords and empty notes:

<pre>
1
2
IV
_
iii
3
</pre>

The whole system is defined for quick editing during live performance or trying out changes to a composition, and as
such, everything is somewhat terse intentionally.








